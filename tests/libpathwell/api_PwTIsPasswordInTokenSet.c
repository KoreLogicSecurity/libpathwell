/*-
 ***********************************************************************
 *
 * $Id: api_PwTIsPasswordInTokenSet.c,v 1.2.2.4 2015/09/30 17:54:51 klm Exp $
 *
 ***********************************************************************
 *
 * Copyright 2013-2015 The PathWell Project, All Rights Reserved.
 *
 * This software, having been partly or wholly developed and/or
 * sponsored by KoreLogic, Inc., is hereby released under the terms
 * and conditions set forth in the project's "README.LICENSE" file.
 * For a list of all contributors and sponsors, please refer to the
 * project's "README.CREDITS" file.
 *
 ***********************************************************************
 */
#if defined(HAVE_CONFIG_H)
#include "config.h"
#endif
#include <inttypes.h>
#include <pathwell.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <tap.h>

typedef struct _TEST_TUPLES
{
  int iTokenSet;
  char acPassword[PATHWELL_MAX_PASSWORD_SIZE];
  int iStatus;
  char acError[256];
} TEST_TUPLES;

unsigned char gaucTokenSet1[] =
{
  0x00,
  //
  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
  0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
  0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
  0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
  0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e,
  //
  //
  //
  //
  //
  //
  //
  //
};
unsigned char gaucTokenSet2[] =
{
  0x00,
  //
  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
  0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
  0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
  0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
  0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e,
  //
  //
  //
  //
  0xc0,       0xc2,                         0xc7, 0xc8, 0xc9, 0xca, 0xcb,             0xce, 0xcf,
                          0xd4,                         0xd9,       0xdb,
  0xe0,       0xe2,                         0xe7, 0xe8, 0xe9, 0xea, 0xeb,             0xee, 0xef,
                          0xf4,                         0xf9,       0xfb,
};
unsigned char gaucTokenSet3[] =
{
  0x00,
  //
  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
  0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
  0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
  0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
  0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e,
  //
  //
  //
  //
  0xc0,       0xc2,       0xc4,             0xc7, 0xc8, 0xc9, 0xca, 0xcb,             0xce, 0xcf,
  0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,       0xdd, 0xde, 0xdf,
  0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
        0xf1,             0xf4,       0xf6,             0xf9,       0xfb,
};
unsigned char gaucTokenSet4[] =
{
  0x00,
  //
  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
  0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
  0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
  0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
  0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e,
  //
  //
  //
  //
  0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
  0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
  0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
  0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6,       0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
};

int
main(int iArgumentCount, char *ppcArgumentVector[])
{
  char acDescription[1024] = "";
  int iError = 0;
  int iIndex = 0;
  int iStatus = 0;
  int iTokenSet = 0;
  PW_T_CONTEXT *psPwTContext = NULL;
  TEST_TUPLES asTuples[] =
  {
    { -1, "", PATHWELL_INDETERMINATE, "Invalid or unsupported token set."},
    { -1, "undef", PATHWELL_INDETERMINATE, "Invalid or unsupported token set."},
    { -1, "password", PATHWELL_INDETERMINATE, "Invalid or unsupported token set."},

    { 0, "", PATHWELL_INDETERMINATE, "Invalid or unsupported token set."},
    { 0, "undef", PATHWELL_INDETERMINATE, "Invalid or unsupported token set."},
    { 0, "password", PATHWELL_INDETERMINATE, "Invalid or unsupported token set."},

    { 5, "", PATHWELL_INDETERMINATE, "Invalid or unsupported token set."},
    { 5, "undef", PATHWELL_INDETERMINATE, "Invalid or unsupported token set."},
    { 5, "password", PATHWELL_INDETERMINATE, "Invalid or unsupported token set."},

    { PATHWELL_TOKEN_SET_ID_1, "undef", PATHWELL_INDETERMINATE, "Password undefined."},
    { PATHWELL_TOKEN_SET_ID_2, "undef", PATHWELL_INDETERMINATE, "Password undefined."},
    { PATHWELL_TOKEN_SET_ID_3, "undef", PATHWELL_INDETERMINATE, "Password undefined."},
    { PATHWELL_TOKEN_SET_ID_4, "undef", PATHWELL_INDETERMINATE, "Password undefined."},

    { PATHWELL_TOKEN_SET_ID_1, "", PATHWELL_TRUE, ""},
    { PATHWELL_TOKEN_SET_ID_2, "", PATHWELL_TRUE, ""},
    { PATHWELL_TOKEN_SET_ID_3, "", PATHWELL_TRUE, ""},
    { PATHWELL_TOKEN_SET_ID_4, "", PATHWELL_TRUE, ""},

    { PATHWELL_TOKEN_SET_ID_1, "password", PATHWELL_TRUE, ""},
    { PATHWELL_TOKEN_SET_ID_2, "password", PATHWELL_TRUE, ""},
    { PATHWELL_TOKEN_SET_ID_3, "password", PATHWELL_TRUE, ""},
    { PATHWELL_TOKEN_SET_ID_4, "password", PATHWELL_TRUE, ""},
  };
  unsigned char aucTokenSet1[256] = { 0 };
  unsigned char aucTokenSet2[256] = { 0 };
  unsigned char aucTokenSet3[256] = { 0 };
  unsigned char aucTokenSet4[256] = { 0 };
  unsigned char *pucTokenSet = NULL;

  for (iIndex = 0; iIndex < sizeof(gaucTokenSet1) / sizeof(gaucTokenSet1[0]); iIndex++)
  {
    aucTokenSet1[gaucTokenSet1[iIndex]] = 1;
  }
  for (iIndex = 0; iIndex < sizeof(gaucTokenSet2) / sizeof(gaucTokenSet2[0]); iIndex++)
  {
    aucTokenSet2[gaucTokenSet2[iIndex]] = 1;
  }
  for (iIndex = 0; iIndex < sizeof(gaucTokenSet3) / sizeof(gaucTokenSet3[0]); iIndex++)
  {
    aucTokenSet3[gaucTokenSet3[iIndex]] = 1;
  }
  for (iIndex = 0; iIndex < sizeof(gaucTokenSet4) / sizeof(gaucTokenSet4[0]); iIndex++)
  {
    aucTokenSet4[gaucTokenSet4[iIndex]] = 1;
  }

  plan_tests(1046);

  psPwTContext = PwTNewContext();
  ok(psPwTContext != NULL, "%s", "new context");

  for (iIndex = 0; iIndex < (sizeof(asTuples) / sizeof(asTuples[0])); iIndex++)
  {
    iError = PwTSetPassword(psPwTContext, strcmp(asTuples[iIndex].acPassword, "undef") ? asTuples[iIndex].acPassword : NULL);
//  ok(iError == 0, "%s", "set topology");
    iError = PwTSetTokenSet(psPwTContext, asTuples[iIndex].iTokenSet);
//  ok(iError == 0, "%s", "set token set");
    iStatus = PwTIsPasswordInTokenSet(psPwTContext);
    if (iStatus == PATHWELL_INDETERMINATE)
    {
      snprintf
      (
        acDescription,
        1024,
        "%d, \"%s\", \"%s\", \"%s\"",
        asTuples[iIndex].iTokenSet,
        asTuples[iIndex].acPassword,
        asTuples[iIndex].acError,
        PwTGetError(psPwTContext)
      );
      ok(strcmp(PwTGetError(psPwTContext), asTuples[iIndex].acError) == 0, "%s", acDescription);
    }
    else
    {
      snprintf
      (
        acDescription,
        1024,
        "%d, \"%s\", %d, %d",
        asTuples[iIndex].iTokenSet,
        asTuples[iIndex].acPassword,
        asTuples[iIndex].iStatus,
        iStatus
      );
      ok(iStatus == asTuples[iIndex].iStatus, "%s", acDescription);
    }
  }

  for (iTokenSet = PATHWELL_MIN_TOKEN_SET_ID; iTokenSet <= PATHWELL_MAX_TOKEN_SET_ID; iTokenSet++)
  {
    switch (iTokenSet)
    {
    case PATHWELL_TOKEN_SET_ID_1:
      pucTokenSet = aucTokenSet1;
      break;
    case PATHWELL_TOKEN_SET_ID_2:
      pucTokenSet = aucTokenSet2;
      break;
    case PATHWELL_TOKEN_SET_ID_3:
      pucTokenSet = aucTokenSet3;
      break;
    case PATHWELL_TOKEN_SET_ID_4:
      pucTokenSet = aucTokenSet4;
      break;
    }
    for (iIndex = 0; iIndex < 256; iIndex++)
    {
      char acPassword[2] = { iIndex, 0 };
      iError = PwTSetPassword(psPwTContext, acPassword);
//    ok(iError == 0, "%s", "set topology");
      iError = PwTSetTokenSet(psPwTContext, iTokenSet);
//    ok(iError == 0, "%s", "set token set");
      iStatus = PwTIsPasswordInTokenSet(psPwTContext);
      if (iStatus == PATHWELL_INDETERMINATE)
      {
        snprintf
        (
          acDescription,
          1024,
          "%d, \"\\x%02x\", %d, \"%s\"",
          iTokenSet,
          iIndex,
          pucTokenSet[iIndex],
          PwTGetError(psPwTContext)
        );
        ok(0, "%s", acDescription);
      }
      else
      {
        snprintf
        (
          acDescription,
          1024,
          "%d, \"\\x%02x\", %d, %d",
          iTokenSet,
          iIndex,
          pucTokenSet[iIndex],
          iStatus
        );
        ok(iStatus == pucTokenSet[iIndex], "%s", acDescription);
      }
    }
  }

  PwTFreeContext(psPwTContext);

  return exit_status();
}
